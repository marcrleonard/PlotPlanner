<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>External SVG + D3</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/javascript" src='js/scripts.js'></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
        crossorigin="anonymous"></script>
</head>


<body>


    <button id='save' onclick="exportFile('This is some dummy data.\nAnd some more dummy data.\n', 'a_btn_writetofile')">
        SAVE IT!!! </button>

    <a id='link'> Link!</a>

    <div>

        <object data="test.svg" type="image/svg+xml" id='load_svg'>
            <svg></svg>
        </object>

        <div id='shadow'>

            <svg id='shadow_svg' width="419.99957mm" height="297.00009mm" viewBox="0 0 1488.1875 1052.3625">
                <metadata id="metadata5434">
                    <rdf:RDF>
                        <cc:Work rdf:about="">
                            <dc:format>image/svg+xml</dc:format>
                            <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                            <dc:title></dc:title>
                        </cc:Work>
                    </rdf:RDF>
                </metadata>
            </svg>
        </div>

        <!-- EMBED METHOD.... -->





        <script>


            // URL pointing to the Blob with the file contents
            var objUrl = null;
            // create the blob with file content, and attach the URL to the downloadlink; 
            // NB: link must have the download attribute
            // this method can go to your library
            function exportFile(fileContent, downloadLinkId) {
                // revoke the old object URL to avoid memory leaks.
                if (objUrl !== null) {
                    window.URL.revokeObjectURL(objUrl);
                }
                // create the object that contains the file data and that can be referred to with a URL
                var data = new Blob([fileContent], { type: 'text/plain' });
                objUrl = window.URL.createObjectURL(data);
                // attach the object to the download link (styled as button)
                var downloadLinkButton = document.getElementById(downloadLinkId);
                downloadLinkButton.href = objUrl;
            };


            function clicker(obj) {
                console.log('clicked!!');
                if (!shadow_svg.includes(obj.id)) {

                    let tag_type = obj.tagName
                    let full_obj = obj;
                    let curr_obj = obj
                    while (tag_type != 'svg') {

                        // $(this).siblings().remove();

                        // itterate up...
                        curr_obj = full_obj;
                        full_obj = full_obj.parentElement;
                        tag_type = full_obj.tagName;
                    }


                    let clone = curr_obj.cloneNode(true)

                    let _ele = clone.querySelector('#' + obj.id)

                    // let _ele = clone.getElementById(obj.id)
                    $(_ele).siblings().remove();

                    clone.style.stroke = 'black';

                    shadow_svg.push(clone);
                    obj.style.stroke = 'green';
                    obj.style.strokeWidth = '2';





                }
                else {
                    var index = shadow_svg.indexOf(obj.id);
                    shadow_svg.pop(index);
                    obj.style.stroke = 'black';
                    obj.style.strokeWidth = '.24';
                    console.log(shadow_svg);
                };

                draw_shadow();
                // obj.style.stroke = 'green';
            };

            function draw_shadow() {
                svg = document.getElementById('shadow_svg');
                svg.innerHTML = '';

                ns_string = "http://www.w3.org/2000/svg";
                var g = document.createElementNS(ns_string, "g");
                g.id = 'shadow_g';
                svg.appendChild(g);


                for (path of shadow_svg) {
                    // o_path = document.getElementById(path);
                    // var n_path = o_path.cloneNode(true);
                    // n_path.id = 'new!';
                    // d = o_path.getAttribute('d');
                    // console.log(d);
                    // var newElement = document.createElementNS("http://www.w3.org/2000/svg", 'path'); //Create a path in SVG's namespace
                    // newElement.setAttribute("d",d); //Set path's data
                    // newElement.style.stroke = "#000"; //Set stroke colour
                    // newElement.style.strokeWidth = "1px"; //Set stroke width

                    // console.log(n_path);
                    // clone = path.cloneNode(true); // true means clone all childNodes and all event handlers
                    // clone.attr('xmlns:myns', ns_string);
                    // clone.id = "clone_" + o_path.id;


                    g.appendChild(path);

                };


            };


            window.onload = function () {



                var a = document.getElementById("load_svg");
                // Get the SVG document inside the Object tag
                var svgDoc = a.contentDocument;
                // Get one of    the SVG items by ID;
                svg_element = svgDoc.firstElementChild





                let supported_elements = ['path', 'circle', 'rect', 'line']




                // def recursivelyTraverseSvg(self, aNodeList,
                //                            matCurrent=[[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],
                //                            parent_visibility='visible'):
                //     """
                //     Recursively traverse the svg file to plot out all of the
                //     paths.  The function keeps track of the composite transformation
                //     that should be applied to each path.

                //     This function handles path, group, line, rect, polyline, polygon,
                //     circle, ellipse and use (clone) elements.  Notable elements not
                //     handled include text.  Unhandled elements should be converted to
                //     paths in Inkscape.



                for (let ele of supported_elements) {

                    paths = svg_element.getElementsByTagName(ele)
                    console.log(paths)
                    for (let path of paths) {


                        path.setAttribute("onclick", "window.parent.clicker(this)");

                    }



                }



                // inside of our d3.xml callback, call another function
                // that styles individual paths inside of our imported svg
                styleImportedSVG();

            };

            var shadow_svg = [];



            // });


            function styleImportedSVG() {
                paths = d3.select('svg');

                all_paths = d3.selectAll('path');
                all_paths.style("color", "green");



                all_paths.on('mouseover', function () {
                    // let x, y
                    // x, y = d3.mouse(this);
                    // consoel.log(x, y);

                    if (!shadow_svg.includes(this.id)) {
                        console.log(this);

                        this.style.stroke = 'red';
                        this.style.strokeWidth = '1';
                        console.log('mouseover');

                    };


                    // console.log('this', this);
                    // path = d3.selectAll('path');
                    // console.log(path);
                    //     path.style({
                    //         // 'fill-opacity': 0.1,
                    //         // 'stroke-opacity': 0.5,
                    //         'stroke': 'green'
                    //     })
                })
                    .on('mouseout', function () {

                        if (!shadow_svg.includes(this.id)) {
                            this.style.stroke = 'black';
                            this.style.strokeWidth = '.24';
                            console.log('mouseout');
                        }



                    })
            }
        </script>
</body>

</html>